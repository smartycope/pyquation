from sympy import flatten, Symbol
from sympy.physics.units import Unit
from functools import reduce
from operator import mul, or_


class CombinedEquation:
    """ A class generated by Equations to aid in using multiple equations together
        Don't instantiate directly. Instead, create a new Equation.
    """

    def __init__(self, *equations):
        self.equations = equations
        self.variables = flatten(eq.variables for eq in equations)
        self._var_lookup = reduce(or_, [eq._var_lookup for eq in equations])

    def __call__(self, seperate_unc=False, fill_unknowns=True, **values) -> dict:
        """ Use this just like you call Equations.
            `seperate_unc`, when True, returns a tuple of 2 dicts, one for the values and one for the uncertainties, instead
                of combining them
            `fill_unknowns`, when True, will will any variables in the returned dict that we still don't know the values of
                with their symbols. When not True or False, it fills them with the given values instead
        """
        uncertainties = {}
        vals = {}
        for key, val in values.items():
            if (var := self._var_lookup.get(key)) is None:
                raise ValueError(f"{key} not in equation {self}")

            if key.endswith('_unc') or key.startswith(('unc_', 'δ')):
                uncertainties[var] = val
            else:
                vals[var] = val

        # Go through all the values, and if there isn't an associated uncertainty, set it to 0
        for val in vals:
            if (sym := Symbol('δ'+str(val), positive=True)) not in uncertainties:
                uncertainties[sym] = 0

        while True:
            prev_len_vals = len(vals)
            for eq in self.equations:
                unknown_vars = eq.variables.difference(vals.keys())
                # If there's a single unknown variable, we can use it
                if len(unknown_vars) == 1:
                    new_var = unknown_vars.pop()
                    new_val, unc = eq(
                        **{str(key): val for key, val in (vals | uncertainties).items()},
                        allow_random_variables=True,
                        tuple=True
                    )
                    vals[new_var] = new_val
                    uncertainties[Symbol('δ'+str(new_var), positive=True)] = unc

            # Keep going until we either know everything, or can't try anything new
            if prev_len_vals == len(vals) or len(vals) == len(self.variables):
                break

        have_unc = any(uncertainties.values())

        # Fill any vals we don't have
        if fill_unknowns is not False:
            for var in self.variables:
                if var not in vals:
                    if fill_unknowns is True:
                        vals[var] = Symbol(str(var))
                    else:
                        vals[var] = fill_unknowns
                if Symbol('δ' + str(var), positive=True) not in uncertainties and have_unc:
                    unc = Symbol('δ'+str(var), positive=True)
                    if fill_unknowns is True:
                        uncertainties[unc] = unc
                    else:
                        uncertainties[unc] = fill_unknowns

        if have_unc:
            if seperate_unc:
                return vals, uncertainties
            else:
                return vals | uncertainties
        return vals

    def __str__(self):
        return ' | '.join(map(str, self.equations))
